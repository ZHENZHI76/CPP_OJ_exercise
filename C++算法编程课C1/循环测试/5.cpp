#include <iostream>

using namespace std;

int main() {
  int x, y, k;
  cin >> x >> y >> k;
  
  if(x == y) {
    cout << 0 << endl;
    return 0;
  }
  
  int g1 = x, g2 = y;
  int ans = -1;
  
  for(int i = 0; i < k; i++) {
    int a, xi, b, yi;
    cin >> a >> xi >> b >> yi;
    
    g1 += a * xi;
    g2 += b * yi;
    
    if(g1 < 0) g1 = 0;
    if(g2 < 0) g2 = 0;
    
    if(g1 == g2) {
      ans = i + 1;
      break;
    }
  }
  
  cout << ans << endl;
  
  return 0;
}

/*
这段代码实现了一个计算公鸡打鸣声音响度值相同时最少经过几次协商的程序。
程序首先读入两只公鸡的响度值 x 和 y，以及协商的次数 k。
如果 x 和 y 相等，那么它们的响度值已经相同，输出 0 并结束程序。
否则，程序进入一个循环，循环 k 次，每次读入 4 个整数 ai、xi、bi 和 yi，表示 G1 和 G2 的响度值分别增加或减少 ai * xi 和 bi * yi。
如果 G1 或 G2 的响度值小于 0，将其设置为 0。如果 G1 和 G2 的响度值相等，记录协商次数 ans 并跳出循环。
最后输出 ans，如果 ans 仍为 -1，说明经过 k 次协商后 G1 和 G2 的响度值仍不相同，输出 -1。
*/

/*
这段C++代码的实现过程是:

1. 定义变量x,y,k来存储G1,G2第一次打鸣的响度值和总的协商次数

2. 检查x和y是否相等,如果相等直接输出0

3. 定义变量g1,g2来跟踪G1和G2当前的响度值,初始化为x和y

4. 定义变量ans来存储使响度值相等的最少协商次数,初始化为-1

5. 用for循环遍历k次协商

6. 每次读取本次协商中G1和G2响度变化值ai,xi,bi,yi

7. 根据ai和xi更新g1的值,根据bi和yi更新g2的值

8. 检查g1和g2是否小于0,如果是则置为0

9. 检查g1和g2是否相等,如果相等则更新ans为当前协商次数+1,并break跳出循环

10. 遍历结束后,如果ans还是-1,说明k次协商后也没能相等

11. 最后输出ans,就是使响度相等的最少协商次数

这样通过跟踪g1和g2的实时响度,每次协商后检查是否相等,就可以计算出使响度相等的最少协商次数。
*/